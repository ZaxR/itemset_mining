from collections import defaultdict, namedtuple
from itertools import chain, combinations
from typing import (Any, Dict, Generator, Iterable,
                    List, Optional, Set, Tuple, Union)


HUIRecord = namedtuple(  # pylint: disable=C0103
    'HUIRecord', ('items', 'twu'))


class TwoPhase:
    """

    Example:
        >>> transactions = [
                [("Coke 12oz", 6), ("Chips", 2), ("Dip", 1)],
                [("Coke 12oz", 1)],
                [("Coke 12oz", 2), ("Chips", 1)],
                [("Chips", 1)],
                [("Chips", 2)],
                [("Coke 12oz", 6), ("Chips", 1)]
            ]

        >>> # ARP for each item
        >>> external_utilities = {
                "Coke 12oz": 1.29,
                "Chips": 2.99,
                "Dip": 3.49
            }

        >>> # Minimum dollar value generated by an itemset we care about across all transactions
        >>> minutil = 20.00

        >>> hui = TwoPhase(transactions, external_utilities, minutil)
        >>> result = hui.get_hui()
        >>> print(list(result))
        [HUIRecord(items=frozenset({'Coke 12oz'}), twu=34.8),
         HUIRecord(items=frozenset({'Chips'}), twu=42.480000000000004),
         HUIRecord(items=frozenset({'Coke 12oz', 'Chips'}), twu=33.510000000000005)]

    """

    def __init__(self, transactions: List[Tuple[Any, Union[int, float]]],
                 external_utilities: Dict, minutil: int):
        self.transactions = transactions

        # For items in transactions, but not in external_utilities,
        # self.external_utilities[item] = 0
        # can still loop through those items for initial candidate set,
        # because if the external utilities are 0, not going to be important anyway
        self.external_utilities = defaultdict(int, external_utilities)
        self.minutil = minutil

        # self.num_transaction = 0
        self._items = list(external_utilities.keys())
        # self._item_transaction_ids = {}  # todo: see if keeping track of item indices offers speedup

    @property
    def items(self):
        """Returns the list of items that appear in transactions."""
        return sorted(self._items)

    def calc_transaction_utility(self, transaction: Tuple[Any, Union[int, float]]):
        return sum([self.external_utilities[item] * internal_utility
                    for item, internal_utility in transaction])

    def calc_twu(self, itemset: List[str]):
        """Calculated the transaction-weighted utilization for an itemset"""
        transaction_utilities = []
        for transaction in self.transactions:
            transaction_itemset = [t[0] for t in transaction]
            if all(item in transaction_itemset for item in itemset):
                transaction_utility = self.calc_transaction_utility(transaction)
                transaction_utilities.append(transaction_utility)
        return sum(transaction_utilities)

    def initial_candidates(self):
        """Returns the initial candidates."""
        return [frozenset([item]) for item in self.items]

    def _create_next_candidates(self, prev_candidates: Set, length: int):
        """ Returns the apriori candidates as a list.

        Args:
            prev_candidates: Previous candidates as a list.
            length: The lengths of the next candidates.

        """
        # Solve the items.
        items = sorted(frozenset(chain.from_iterable(prev_candidates)))

        # Create the temporary candidates. These will be filtered below.
        tmp_next_candidates = (frozenset(itemset) for itemset in combinations(items, length))

        # Return all the candidates if the length of the next candidates is 2
        # because their subsets are the same as items.
        if length < 3:
            return list(tmp_next_candidates)

        # Filter candidates that all of their subsets are
        # in the previous candidates.
        next_candidates = [
            candidate for candidate in tmp_next_candidates
            if all(
                frozenset(itemset) in prev_candidates
                for itemset in combinations(candidate, length - 1))
        ]
        return next_candidates

    def get_hui(self, max_length: Optional[int] = None) -> Generator[HUIRecord, None, None]:
        """Returns a generator of support records with given transactions."""
        candidate_itemsets = self.initial_candidates()
        length = 1
        while candidate_itemsets:
            high_util_itemsets = set()
            for candidate_itemset in candidate_itemsets:
                twu = self.calc_twu(candidate_itemset)
                # print(f"itemset: {candidate_itemset}, twu: {twu}")
                if twu < self.minutil:
                    continue
                high_util_itemsets.add(candidate_itemset)
                yield HUIRecord(candidate_itemset, twu)
            length += 1
            if max_length and length > max_length:
                break
            candidate_itemsets = self._create_next_candidates(high_util_itemsets, length)
